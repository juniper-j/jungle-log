"""
[문제 해결 단계]
1. 입력받은 지역 높이 정보를 활용하여, 가능한 모든 물 높이(h)에서 안전한 영역의 개수를 구한다.
2. 물 높이 h를 0부터 99까지 변화시키며:
   - 모든 위치를 탐색하여 방문 여부를 체크하고, 방문하지 않았으면서 h보다 높은 곳은 BFS 탐색을 수행.
   - BFS를 사용하여 하나의 연결된 영역을 방문하면, 해당 영역을 하나의 "안전 영역"으로 카운트.
3. 매 높이 h마다 탐색 후 얻은 안전 영역 개수 중 최댓값을 저장하여 출력한다.

[구현 방식]
- BFS (너비 우선 탐색) 방식 사용: 큐(deque)를 활용하여 인접한 지역을 탐색.
- 2차원 리스트 v를 이용하여 방문 여부를 관리.
- 높이 h를 0부터 99까지 변화시키며 가능한 최대 영역 개수를 찾음.
"""

from collections import deque

def bfs(si, sj, h):
    """BFS를 사용하여 연결된 안전 영역을 탐색"""
    q = deque()  # BFS 탐색을 위한 큐 생성
    q.append((si, sj))  # 시작 위치 큐에 추가
    v[si][sj] = 1  # 방문 표시

    while q:
        ci, cj = q.popleft()  # 큐에서 현재 위치를 꺼냄

        # 상, 하, 좌, 우 네 방향 탐색
        for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):
            ni, nj = ci + di, cj + dj  # 이동할 위치 계산

            # (1) 범위 내에 있어야 함
            # (2) 아직 방문하지 않은 곳이어야 함
            # (3) 물에 잠기지 않은 지역이어야 함 (높이 h보다 높아야 함)
            if 0 <= ni < N and 0 <= nj < N and v[ni][nj] == 0 and arr[ni][nj] > h:
                q.append((ni, nj))  # 탐색할 위치 큐에 추가
                v[ni][nj] = 1  # 방문 처리

def solve(h):
    """h 높이에서 안전 영역 개수를 계산하는 함수"""
    cnt = 0  # 현재 높이에서의 안전 영역 개수를 저장할 변수

    # 전체 지도 탐색
    for i in range(N):
        for j in range(N):
            # 방문하지 않았고, 물에 잠기지 않은 지역이면 새로운 안전 영역 탐색 시작
            if v[i][j] == 0 and arr[i][j] > h:
                bfs(i, j, h)  # BFS 탐색 수행
                cnt += 1  # 새로운 안전 영역이므로 개수 증가

    return cnt  # 해당 높이에서의 안전 영역 개수 반환

# 입력 처리
N = int(input())  # 지역 크기 입력
arr = [list(map(int, input().split())) for _ in range(N)]  # 지역의 높이 정보 입력

ans = 0  # 안전 영역의 최대 개수를 저장할 변수
for h in range(100):  # 물 높이 0부터 99까지 변하며 탐색
    v = [[0] * N for _ in range(N)]  # 방문 체크 배열 초기화
    ans = max(ans, solve(h))  # 현재 높이에서 찾은 안전 영역 개수와 비교하여 최댓값 갱신

# 최종 결과 출력
print(ans)